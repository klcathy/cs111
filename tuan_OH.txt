April 2nd
-----------
1a: parse script/testfile and store commands in to predefined structure
b: implement execution model
c: parallelism/concurrency*		fork()

1a: read-command.c
	-make_command_stream
		-
	-read_command_stream
		-take output from make_command_stream and return 1 command at a time
		-store stream like a linked list c1 -> c2 -> c3
		-return next command in linked list, e.g. return next token
		-specify data structure for command_stream_t and becomes input for read_command_stream

// define this is in command.h
// create linked list for this node
struct command_Node {
	struct command *command;		// already defined in command-internals.h
	struct command Node *next;
};

typedef struct command_stream {
	struct command Node *head;
	struct command Node *tail;
} command_stream;

struct command 
{
	enum command_type type;
	int status;		// not needed till lab 1b, can just set to -1
	char *input;
	char *output;

	union
	{
		struct command *command[2];
		char **word;		// terminated by 0 byte
		struct command *subshell_command;
	} u;
}

echo abc:		<- char *str 
-simple command
		struct command *simpleCommand =
			(struct command *) malloc (sizeof(struct command));
		simpleCommand -> type = SIMPLE_COMMAND;
		simpleCommand->status = -1;
		simpleCommand->input = NULL;
		simpleCommand->output = NULL;
		simpleCommand->u.word = (char**)malloc(2*sizeof(char*));
		simpleCommand->u.word[0] = str;
		simpleCommand->u.word[1] = 0;

if its echo < abc, str only stores echo, but input stores abc

a && b || c:

simpleCommand_a;
simpleCommand_b;
simpleCommand_c;
and_command
	type = AND_COMMAND;
	status = -1;
	input = NULL;
	output = NULL;
	u.command[0] = &simple_command a;
	u.command[1] = &simple_command b;
	don't need to story anything for word

or_command
	type = OR_COMMAND;
	status = -1;
	input = NULL;
	output = NULL;
	u.command[0] = &and_command;
	u.command[1] = &simple_command c

&& and || has same operator precedence
pipe has highest precedence

d || e | f && g

1. e | f
2. d || e | f
3. whole thing

pipe_command:	left: e  right: f
	or_command: left: d right: pipe
		and_command left: OR right: g

How to automate this	(use two stacks)
	command_stack
	operator_stack

pseudocode:
	if encounter new operator:
		if operator_stack == NULL:
			add new operator to operator stack
		else:
		{
			if precedence (new_operator) > precedence (top_operator):
				add new_operator to operator_stack
			else: {
				while top_operator != OPEN_PARANTHESES && precendence(new_operator) <= precedence(top_operator):
					operator = operator_stack.pop();
					second_command = command_stack.pop();
					first_command = command_stack.pop();
					new_command = combineCommand(first_command, second_command, operator);
					command_stack.push(new_command);
					top_operator = operator_stack.peek();
					if (top_operator == NULL):
						break;
				}	
		operator_stack.push(new_operator);
		}

operator Precedence:
	1. semicolon, newline		assign int 0
	2. And, or                             1
	3. Pipe              highest           2

a;b\nc
left: a;b 	right: c

a;b\n\nc
two separate command nodes

b: execute-command.c

if (c) // false

cat a.txt	// a.txt doesnt exist
echo $?		// get return status of last command